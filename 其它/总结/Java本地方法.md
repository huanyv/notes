# Java本地方法（native）

[toc]

## 1. 编写native方法

```java
public class test {
	static {
		System.loadLibrary("dllmain");
	}
    public static void main(String[] args) {
        print("你好");
    }
    public native static void print(String s);
   
}
```

## 2. 生成头文件

* 执行`javah -jni test`
* 生成头文件如下

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class test */

#ifndef _Included_test
#define _Included_test
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     test
 * Method:    print
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_test_print
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

## 3. C/C++实现

* `dllmain.c`名字任取

```c
#include "jni.h"
#include <stdio.h>
#include "test.h"


JNIEXPORT void JNICALL Java_test_print(JNIEnv * env, jclass cls, jstring str) {
	// jstring不能直接使用
	char * JAVAchars = (char*)(*env) -> GetStringUTFChars(env, str, NULL);
    printf("%s", JAVAchars);
}
```

## 4. 生成动态连接库
* `.dll`文件

```
gcc -I"D:\Software\ApplicationSoftware\JDK\include" -I"D:\Software\ApplicationSoftware\JDK\include\win32" -Wl,--add-stdcall-alias -shared -o dllmain.dll dllmain.c
```

```
gcc -m64  -Wl,--add-stdcall-alias -I"D:\Software\ApplicationSoftware\JDK\include" -I"D:\Software\ApplicationSoftware\JDK\include/win32" -shared -o dllmain.dll dllmain.c
```

![目录结构](https://img-blog.csdnimg.cn/1eb7354a7fd64dda8b1b5e2be19003ab.jpeg#pic_center)

## 5. 运行

* 导入`System.loadLibrary("dllmain");`
* 其中，和`.dll`文件名一样，不要后缀
* <https://blog.csdn.net/ring0hx/article/details/3242245>


## idea打包
* `javah -jni -classpath "C:\Users\admin\Desktop\untitled\src\main\java" org.example.impl.Print`
* 打包jar包后，不能从jar包加载`dll`文件
* 从classpath中copy到本地缓存中，从本地加载

```java
public class WindowsPrinter implements Print {

	// dll本地缓存目录
    public static final String DLL_CACHE = System.getProperty("java.io.tmpdir");
	// dll文件名
    public static final String DLL_NAME = "dllmain.dll";

    static {
    	// dll缓存到本地
        cacheDll();
        // 从本地加载dll文件
        System.load(DLL_CACHE + File.separator + DLL_NAME);
    }
    @Override
    public native void install();

    @Override
    public native void uninstall();

    public static void cacheDll() {
        InputStream inputStream = null;
        FileOutputStream outputStream = null;
        try {
            inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(DLL_NAME);
            outputStream = new FileOutputStream(DLL_CACHE + File.separator + DLL_NAME);
            byte[] buffer = new byte[1024];
            int len = 0;
            while ((len = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, len);
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (outputStream != null) {
                try {
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

}
```